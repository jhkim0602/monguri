# 협업 규칙 점검 보고서

- 기준일: 2026-02-08
- 점검 범위: 로컬 저장소 산출물(문서/코드/Git 이력) 기준
- 제외 범위: Slack/Notion/GitHub PR 화면 등 외부 운영 데이터

## 1) 지켜지고 있는 것

1. 결정/요구사항/수용기준 문서화가 되어 있다.
   - 근거: `docs/specs/001-mentor-rebuild/spec.md:18`
   - 근거: `docs/specs/001-mentor-rebuild/spec.md:96`
2. 날짜 기반 진행 로그를 기록하고 있다.
   - 근거: `docs/specs/001-mentor-rebuild/progress.md:3`
3. 검증 가이드 및 체크리스트 문서가 존재한다.
   - 근거: `AiContext/Phase3_Planner_Mock_To_API_Verification_Guide.md:50`
   - 근거: `AiContext/Mentee_Backend_Priority_Report.md:45`

## 2) 안 지켜지고 있는 것 (저장소 기준)

1. Single Source of Truth가 깨져 있다.
   - `tasks.md`는 전부 미체크인데, `progress.md`에는 완료성 작업 로그가 다수 존재함.
   - 근거: `docs/specs/001-mentor-rebuild/tasks.md:4`
   - 근거: `docs/specs/001-mentor-rebuild/progress.md:15`
2. 모든 일을 티켓으로 관리하는 구조(Why/What/Done)가 없다.
   - 근거: `docs/specs/001-mentor-rebuild/tasks.md:1`
3. DRI(단일 책임자) 표기가 없다.
   - 근거: `docs/specs/001-mentor-rebuild/progress.md:1`
4. 브랜치 네이밍 규칙(`feat|fix|chore|refactor/티켓번호-키워드`) 준수 흔적이 없다.
   - 점검 결과: 확인된 원격 브랜치 중 일치 0건
5. 커밋 컨벤션 일관성이 낮다.
   - 점검 결과: 최근 66개 중 `feat|fix|chore|refactor:` 시작 메시지 5개
6. 리뷰/승인 강제 장치가 없다.
   - `.github` 디렉터리, workflow, PR 템플릿, `CODEOWNERS` 미존재
7. 품질 게이트가 약하다.
   - `test` 스크립트 없음, `lint`만 정의됨
   - 근거: `package.json:5`
   - 근거: `package.json:9`
8. lint 게이트가 현재 자동 검증 가능한 상태가 아니다.
   - `npm run lint` 실행 시 ESLint 초기 설정 프롬프트가 떠서 비대화형 환경에서 실패
9. 디자인 handoff 계약 문서(props/states/variants) 및 전/후 스냅샷 근거가 없다.
   - 코드 레벨 variants는 존재하나 문서 계약이 없음
   - 근거: `src/components/ui/components/button.tsx:8`
10. 데모/릴리즈 규칙(Freeze Time, Demo Rehearsal) 문서화 흔적이 없다.
   - 근거: `docs/specs/001-mentor-rebuild/quickstart.md:1`

## 3) 판단 불가 (저장소 밖 데이터 필요)

1. 채널 분리 운영(`announce/decision/dev/urgent`)
2. 응답 SLA(근무시간 2시간 내 1차 응답)
3. 회의 운영(사전 공유, 3줄 결과: 결정/담당/마감)
4. 긴급 채널 사용 기준 준수율

## 4) 요약

- 문서 기반 기획/진행 기록은 존재하지만, 운영 규칙을 강제하는 자동화/템플릿/리뷰 게이트가 부족하다.
- 특히 티켓/DRI/브랜치·커밋 컨벤션/PR 승인/테스트 규칙은 저장소 구조로는 아직 정착되지 않았다.

## 5) 우리 팀 실천형 그라운드룰 (파일 기반 제안)

아래 규칙은 현재 저장소에서 실제로 반복되는 작업 방식(spec/plan/tasks/progress, mock→API 전환, 검증 가이드)을 기준으로 정리했다.

1. 시작은 `spec.md`, 끝은 `progress.md`로 맞춘다.
   - 작업 시작 전 범위/수용기준을 `spec.md`에서 확인한다.
   - 작업 종료 후 변경 사실은 같은 날 `progress.md`에 남긴다.
2. 큰 작업은 Phase 단위로 쪼개고, 완료 기준을 체크박스로 관리한다.
   - `tasks.md`는 우선순위/진행률 관리판으로 사용한다.
   - “완료”는 체크박스와 진행 로그가 동시에 맞아야 인정한다.
3. 기획 변경은 “결정 사항” 섹션에 먼저 남기고 구현한다.
   - 라우팅, 데이터 소스, 화면 구조 같은 큰 변경은 `spec.md`의 결정/오픈질문에 기록한다.
4. 데이터 전환은 `Mock → API` 가이드를 먼저 만든 뒤 진행한다.
   - API 연동 작업은 검증 가이드(엔드포인트/예상값/오류케이스)를 기준으로 검수한다.
5. API/DB 변경은 레이어 분리를 유지한다.
   - Route Handler는 HTTP, Service는 비즈니스 로직, Repository는 DB 접근 역할을 분리한다.
6. UI 작업은 “동작 변화” 중심으로 기록한다.
   - 단순 “UI 수정” 대신, 사용자 흐름 기준으로 무엇이 달라졌는지 `progress.md`에 남긴다.
7. 임시 저장(localStorage)과 실제 데이터(API)를 구분해서 명시한다.
   - 임시 저장 키는 문서에 남기고, API 이관 계획을 함께 적는다.
8. 검증 가능한 근거를 문서에 남긴다.
   - 완료 보고 시 “파일 경로 + 기준 라인/섹션”을 함께 적어 재확인이 가능해야 한다.
9. 릴리즈 전 최소 수동 검증 루틴을 고정한다.
   - `/home`, `/planner`, `/calendar`, `/mentor` 핵심 경로는 작업 후 직접 확인한다.
10. 불완전한 규칙은 “판단 불가”로 분리해 누적 관리한다.
   - 저장소 근거로 판단 가능한 것과 외부 운영 데이터가 필요한 항목을 분리해 관리한다.

## 6) 디자인/프론트 협업 규칙 (실천형 제안)

아래 규칙은 현재 진행 로그의 UI 개선 방식과 멘티/멘토 공존 구조를 기준으로 정리했다.

1. 화면 단위로 작업 범위를 먼저 고정한다.
   - 시작 전에 `route + 주요 컴포넌트`를 같이 적는다. 예: `/planner` + `src/components/mentee/planner/*`.
2. UI 변경은 전/후 증거를 남긴다.
   - 변경 전 1장, 변경 후 1장 스냅샷과 함께 “무엇이 바뀌었는지” 2줄 설명을 기록한다.
3. 공용 컴포넌트 변경 시 계약(props/states/variants)을 같이 갱신한다.
   - 버튼/카드/모달처럼 재사용 컴포넌트는 시그니처와 상태 케이스를 문서 또는 코드 주석으로 남긴다.
4. “예쁘다”보다 사용자 흐름 변화를 기준으로 리뷰한다.
   - 리뷰 코멘트는 클릭 수 감소, 정보 우선순위, 에러/빈 상태 처리 여부를 근거로 작성한다.
5. UI 작업과 데이터 작업을 분리해서 관리한다.
   - 같은 기능이라도 레이아웃 정리와 API 연동은 분리 기록하거나 PR을 분리한다.
6. 반응형 기준을 작업 완료 조건에 포함한다.
   - 최소 모바일 1개 폭과 데스크톱 1개 폭에서 레이아웃 깨짐 없이 동작해야 완료로 본다.
7. 로딩/에러/빈 상태를 기본 화면과 같은 우선순위로 다룬다.
   - 정상 데이터 화면만 만들고 종료하지 않고, 빈 데이터와 실패 케이스까지 확인한다.
8. Mock 데이터 사용 시 API 전환 포인트를 같이 남긴다.
   - 임시 데이터 필드는 어디까지이고, API 붙일 때 교체할 경계를 함께 기록한다.
9. UI 텍스트/라벨 변경도 변경사항으로 기록한다.
   - 버튼 문구, 상태명, 탭명 같은 카피 변경은 사용자 영향이 있으므로 진행 로그에 남긴다.
10. 병합 전 핵심 경로를 짧게 재현 테스트한다.
   - 최소 `/home`, `/planner`, `/calendar`, `/mentor` 진입과 주요 상호작용 1회는 수동 확인 후 병합한다.

## 7) 백엔드 협업 규칙 (실천형 제안)

아래 규칙은 현재 API 구현 패턴(Route + Validator + Service + Repository)과 검증 문서 운영 방식 기준으로 정리했다.

1. Route는 HTTP 처리만 담당하고 비즈니스 로직은 Service로 넘긴다.
   - 요청 파싱/응답 반환/에러 핸들링까지만 Route에서 처리한다.
2. 입력 검증은 Zod `safeParse`로 먼저 막고, 실패 시 400으로 즉시 반환한다.
   - query/body/param 모두 validator 파일에서 스키마로 관리한다.
3. 예외 처리는 `HttpError` + `handleRouteError` 패턴으로 통일한다.
   - 예상 가능한 도메인 오류(권한/미존재/유효성)는 상태코드와 메시지를 명시해 던진다.
4. Service에서 역할(role)과 리소스 소유권(ownership)을 검증한다.
   - 멘티/멘토 프로필 확인, mentor-mentee 매칭 확인을 먼저 통과해야 데이터 변경이 가능하다.
5. Repository는 DB 접근만 담당한다.
   - 테이블 조회/삽입/갱신/삭제 쿼리와 정렬/필터 조건만 유지하고, 업무 규칙 판단은 넣지 않는다.
6. DB 컬럼(snake_case)과 API 응답(camelCase) 변환은 Service에서 책임진다.
   - 응답 형태를 안정적으로 유지해 프론트 영향 범위를 줄인다.
7. 상태 전이 규칙은 Service에서 명시적으로 관리한다.
   - 예: 제출/피드백/완료 같은 상태 흐름은 DB 업데이트 전에 조건을 검증한다.
8. 과목/파일 등 참조 데이터는 생성 전에 존재 여부를 확인한다.
   - `subjectSlug`, `fileId` 같은 참조 키는 선검증 후 저장한다.
9. 백엔드 작업은 Phase 체크리스트로 쪼개서 진행한다.
   - 공통 기반 → 조회 → 쓰기/상태 전이 → 파일/고급 기능 순으로 리스크를 낮춘다.
10. Mock → API 전환은 검증 가이드(MCP/API/UI)로 교차 확인한다.
   - 엔드포인트 응답과 DB 원천 데이터, UI 반영 결과를 같은 시나리오로 확인한다.

## 8) 공통 협업 규칙 (실천형 제안)

아래 규칙은 프론트/백엔드 모두에 공통으로 적용한다.

1. 작업 시작 전 `목적/범위/완료조건`을 먼저 고정한다.
   - 최소 한 줄이라도 남기고 시작하며, 중간 변경 시 즉시 업데이트한다.
2. 작업 단위는 작게 나눠서 진행한다.
   - 한 번에 큰 변경을 넣기보다 기능/레이어 단위로 분리해 충돌과 회귀를 줄인다.
3. 근거 중심으로 커뮤니케이션한다.
   - 의견/결론을 말할 때 파일 경로와 섹션(또는 라인)을 같이 남긴다.
4. 결정 사항과 진행 로그를 분리해 기록한다.
   - “무엇을 하기로 했는지”와 “실제로 무엇을 했는지”를 같은 문서에 섞지 않는다.
5. 임시 처리와 최종 설계를 구분해서 표시한다.
   - mock/localStorage/임시 파라미터는 유지 이유와 이관 계획을 함께 남긴다.
6. 검증 가능한 변경만 완료로 본다.
   - 코드 수정만으로 끝내지 않고 API 응답/UI 동작/에러 케이스 중 필요한 검증을 포함한다.
7. 실패 케이스를 기본 요구사항으로 다룬다.
   - 권한 오류, 빈 데이터, 잘못된 입력, 네트워크 실패를 최소 1회 이상 확인한다.
8. 리뷰 포인트는 취향보다 영향도로 정리한다.
   - 성능, 안정성, 가독성, 확장성, 사용자 흐름에 미치는 영향을 기준으로 코멘트한다.
9. 미완료/리스크는 숨기지 않고 당일 기록한다.
   - 보류 사유와 다음 액션을 명시해 다음 작업자가 바로 이어받을 수 있게 한다.
10. 반복되는 절차는 템플릿으로 고정한다.
   - 매번 설명이 필요한 작업은 체크리스트/가이드로 문서화해 팀 공통 자산으로 만든다.
